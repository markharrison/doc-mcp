"use strict";(self.webpackChunkdoc_mcp=self.webpackChunkdoc_mcp||[]).push([[314],{1589:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/pattern4-bec7d2835b376908d086af971e6718bc.png"},1776:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"why-mcp","title":"Why MCP?","description":"To understand why MCP is needed, lets start by looking at the patterns that modern AI Agents rely on.","source":"@site/docs/02-why-mcp.md","sourceDirName":".","slug":"/why-mcp","permalink":"/doc-mcp/why-mcp","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_label":"Why MCP?","slug":"/why-mcp"},"sidebar":"tutorialSidebar","previous":{"title":"Introduction","permalink":"/doc-mcp/"},"next":{"title":"What is MCP?","permalink":"/doc-mcp/what-is-mcp"}}');var a=t(4848),s=t(8453);const o={sidebar_label:"Why MCP?",slug:"/why-mcp"},r="Why MCP?",l={},c=[{value:"Common AI Patterns",id:"common-ai-patterns",level:2},{value:"Chat",id:"chat",level:3},{value:"RAG - Retrieval-Augmented Generation",id:"rag---retrieval-augmented-generation",level:3},{value:"Tool/Function Calling",id:"toolfunction-calling",level:3},{value:"Combined: Chat + RAG + Tool Use",id:"combined-chat--rag--tool-use",level:3},{value:"Microsoft AI Agent",id:"microsoft-ai-agent",level:2},{value:"Semantic Kernel",id:"semantic-kernel",level:3},{value:"Azure AI Foundry",id:"azure-ai-foundry",level:3},{value:"The Problem",id:"the-problem",level:2},{value:"The Solution - Plug &amp; Play",id:"the-solution---plug--play",level:2}];function d(e){const n={h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"why-mcp",children:"Why MCP?"})}),"\n",(0,a.jsx)(n.p,{children:"To understand why MCP is needed, lets start by looking at the patterns that modern AI Agents rely on."}),"\n",(0,a.jsx)(n.h2,{id:"common-ai-patterns",children:"Common AI Patterns"}),"\n",(0,a.jsx)(n.h3,{id:"chat",children:"Chat"}),"\n",(0,a.jsx)(n.p,{children:"The Chat pattern is a conversational interface between an Agent and an AI Endpoint, typically using natural language, though it can also involve structured inputs or metadata depending on the use case."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:t(7384).A+"",width:"1280",height:"192"})}),"\n",(0,a.jsx)(n.p,{children:'The first message sent to an AI endpoint includes a system prompt, which defines the AI\'s behavior (e.g., "You are a helpful assistant. Be professional."), and a user prompt, which contains the actual request or question from the user.'}),"\n",(0,a.jsx)(n.p,{children:"The AI's response is then added to the chat history, and each subsequent message builds on this context. Over time, the AI refines its understanding of the user's intent, delivering increasingly relevant responses."}),"\n",(0,a.jsx)(n.p,{children:"However, these AI endpoints have a key limitation: they are trained only on data available up to a specific cut-off date. Their training data is typically public, meaning they lack access to domain-specific or proprietary knowledge."}),"\n",(0,a.jsx)(n.p,{children:"To address this, one option is fine-tuning\u2014a process in which the base model is retrained on custom data to better align with specific goals or domains. While effective, fine-tuning is computationally expensive, time-consuming, and requires ongoing maintenance as data evolves."}),"\n",(0,a.jsx)(n.p,{children:"This is where the next pattern, Retrieval-Augmented Generation, can help."}),"\n",(0,a.jsx)(n.h3,{id:"rag---retrieval-augmented-generation",children:"RAG - Retrieval-Augmented Generation"}),"\n",(0,a.jsx)(n.p,{children:"The Retrieval-Augmented Generation (RAG) pattern enhances model responses by retrieving relevant external knowledge at runtime. This allows the AI to incorporate up-to-date or proprietary information into its answers\u2014without requiring retraining of the base model."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:t(2659).A+"",width:"1280",height:"240"})}),"\n",(0,a.jsx)(n.p,{children:"It works by having the agent, during a conversation, access an external knowledge source, extract relevant content based on the user's query, and include that information in the chat message."}),"\n",(0,a.jsx)(n.p,{children:"For example, it might use Bing to fetch the latest data from the internet, or pull organization-specific knowledge from an internal system like SharePoint."}),"\n",(0,a.jsx)(n.h3,{id:"toolfunction-calling",children:"Tool/Function Calling"}),"\n",(0,a.jsx)(n.p,{children:"The Tool / Function Calling pattern extends AI capabilities by integrating with external APIs and services."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:t(5082).A+"",width:"1280",height:"280"})}),"\n",(0,a.jsx)(n.p,{children:"The AI endpoint is made aware of a predefined set of tools it can use to perform actions, retrieve data, or execute code. As the conversation progresses, the AI evaluates user intent and decides whether to invoke one of these tools."}),"\n",(0,a.jsx)(n.p,{children:"Examples of tools include:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Azure Functions \u2013 to execute serverless code"}),"\n",(0,a.jsx)(n.li,{children:"Azure Logic Apps \u2013 to trigger workflows"}),"\n",(0,a.jsx)(n.li,{children:"OpenAPI-defined endpoints \u2013 to call APIs"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"This pattern transforms the AI from a reactive conversational agent into an intelligent application capable of interacting with external systems\u2014for example, issuing alerts, executing queries, or performing operational tasks."}),"\n",(0,a.jsx)(n.h3,{id:"combined-chat--rag--tool-use",children:"Combined: Chat + RAG + Tool Use"}),"\n",(0,a.jsx)(n.p,{children:"Bringing it all together, the complete pattern combines chat, RAG, and tool calling into a single, powerful system."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:t(1589).A+"",width:"1280",height:"396"})}),"\n",(0,a.jsx)(n.h2,{id:"microsoft-ai-agent",children:"Microsoft AI Agent"}),"\n",(0,a.jsx)(n.p,{children:"Let's reimagine the pattern as a three-tier architecture, offering a clearer separation of responsibilities across the system:"}),"\n",(0,a.jsx)(n.p,{children:"At the core of the system is the agent itself \u2014 the brain of the application. This is where intelligence, reasoning, and decision-making occur. The agent manages context, interprets user intent, and determines how to respond or which tools to invoke."}),"\n",(0,a.jsx)(n.p,{children:"The front-end layer is how the agent is accessed. This could be a user-facing interface, like Microsoft Copilot, or another agent interacting programmatically. It captures input and handles responses."}),"\n",(0,a.jsx)(n.p,{children:"The back-end layer connects the agent to external data and services. This includes AI models and services, tool and function calling mechanisms, data retrieval systems (such as RAG), and third-party APIs like weather services or calendar integrations. By leveraging this layer, the agent can augment its capabilities, access real-time information, and take meaningful actions\u2014moving beyond static responses to deliver dynamic, context-aware outcomes."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:t(2492).A+"",width:"1280",height:"571"})}),"\n",(0,a.jsx)(n.h3,{id:"semantic-kernel",children:"Semantic Kernel"}),"\n",(0,a.jsx)(n.p,{children:"There are various software libraries available for building AI applications. Microsoft's solution is the Semantic Kernel - an open-source, lightweight, and extensible framework designed to reduce the amount of code developers need to write. It is fully supported by Microsoft, so if users encounter issues, they can reach out for assistance.\nconnectors to AI services, so if an application uses OpenAI today but needs to switch to an alternative model later, developers can simply change the connector without modifying the application logic. Additional features include memory and context handling, prompt management, and plugins for integrating with external APIs like weather services or Bing Search. Telemetry capabilities help with application observability. Semantic Kernel also includes two sub-frameworks: the Agent Framework, which manages interactions between multiple agents, and the Process Framework, which supports event-driven process management."}),"\n",(0,a.jsx)(n.h3,{id:"azure-ai-foundry",children:"Azure AI Foundry"}),"\n",(0,a.jsx)(n.p,{children:"Azure AI Foundry is Microsoft's unified platform for building, customizing, and deploying AI applications and agents at scale. It provides a full AI toolchain, including access to a broad range of foundation models, the Azure AI Agent Service for orchestrating agent behavior, and seamless integration with Azure services. Designed for enterprise-grade production, it also embeds responsible AI principles\u2014fairness, reliability, safety, privacy, inclusiveness, transparency, and accountability\u2014through built-in governance, observability, and compliance tools."}),"\n",(0,a.jsx)(n.h2,{id:"the-problem",children:"The Problem"}),"\n",(0,a.jsx)(n.p,{children:"While these AI patterns unlock powerful capabilities, they also introduce significant integration challenges. Every service is different, with unique APIs, endpoints, message formats, and authentication schemes."}),"\n",(0,a.jsx)(n.p,{children:"As a result, developers are forced to build and maintain custom logic for each integration. This not only increases technical debt but also makes scaling more burdensome. As the number of tools expands, complexity grows\u2014slowing innovation, reducing agility, and making it harder to adapt to change"}),"\n",(0,a.jsx)(n.h2,{id:"the-solution---plug--play",children:"The Solution - Plug & Play"}),"\n",(0,a.jsx)(n.p,{children:"Those old enough will remember the PCs of the nineties\u2014and what a pain it was to install new hardware like printers or sound cards. Then along came Plug & Play (PnP) and USB, supported by Windows 95 - you just connected the device, and it was automatically recognized, drivers installed and configured ... and it just worked."}),"\n",(0,a.jsx)(n.p,{children:"Developers need the same level of plug-and-play simplicity for AI services. That's exactly what the Model Context Protocol (MCP) delivers: a standard mechanism for integrating tools and services. MCP abstracts away API complexities, letting you focus on building intelligent agents\u2014not grappling with interfaces."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},2492:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/pattern5-b5eded088fd7003b23bf2c58d182deae.png"},2659:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/pattern2-2a8b6be051ad318f7c622a5308a4040e.png"},5082:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/pattern3-76ca716c75c67bb220bd4ebcbb7c1149.png"},7384:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/pattern1-541830870a5a3852ae867d7f079c6a86.png"},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var i=t(6540);const a={},s=i.createContext(a);function o(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);